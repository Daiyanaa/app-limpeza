"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sql-escaper";
exports.ids = ["vendor-chunks/sql-escaper"];
exports.modules = {

/***/ "(rsc)/./node_modules/sql-escaper/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/sql-escaper/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Adapted from https://github.com/mysqljs/sqlstring/blob/cd528556b4b6bcf300c3db515026935dedf7cfa1/lib/SqlString.js\n * MIT LICENSE: https://github.com/mysqljs/sqlstring/blob/cd528556b4b6bcf300c3db515026935dedf7cfa1/LICENSE\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.raw = exports.format = exports.escape = exports.arrayToList = exports.bufferToString = exports.objectToValues = exports.escapeId = exports.dateToString = void 0;\nconst node_buffer_1 = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst regex = {\n    backtick: /`/g,\n    dot: /\\./g,\n    timezone: /([+\\-\\s])(\\d\\d):?(\\d\\d)?/,\n    escapeChars: /[\\0\\b\\t\\n\\r\\x1a\"'\\\\]/g,\n};\nconst CHARS_ESCAPE_MAP = {\n    '\\0': '\\\\0',\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\x1a': '\\\\Z',\n    '\"': '\\\\\"',\n    \"'\": \"\\\\'\",\n    '\\\\': '\\\\\\\\',\n};\nconst charCode = {\n    singleQuote: 39,\n    backslash: 92,\n    dash: 45,\n    slash: 47,\n    asterisk: 42,\n    questionMark: 63,\n    newline: 10,\n    space: 32,\n    tab: 9,\n    carriageReturn: 13,\n};\nconst isRecord = (value) => typeof value === 'object' && value !== null && !Array.isArray(value);\nconst isWordChar = (code) => (code >= 65 && code <= 90) ||\n    (code >= 97 && code <= 122) ||\n    (code >= 48 && code <= 57) ||\n    code === 95;\nconst isWhitespace = (code) => code === charCode.space ||\n    code === charCode.tab ||\n    code === charCode.newline ||\n    code === charCode.carriageReturn;\nconst hasOnlyWhitespaceBetween = (sql, start, end) => {\n    if (start >= end)\n        return true;\n    for (let i = start; i < end; i++) {\n        const code = sql.charCodeAt(i);\n        if (code !== charCode.space &&\n            code !== charCode.tab &&\n            code !== charCode.newline &&\n            code !== charCode.carriageReturn)\n            return false;\n    }\n    return true;\n};\nconst toLower = (code) => code | 32;\nconst matchesWord = (sql, position, word, length) => {\n    for (let offset = 0; offset < word.length; offset++)\n        if (toLower(sql.charCodeAt(position + offset)) !== word.charCodeAt(offset))\n            return false;\n    return ((position === 0 || !isWordChar(sql.charCodeAt(position - 1))) &&\n        (position + word.length >= length ||\n            !isWordChar(sql.charCodeAt(position + word.length))));\n};\nconst skipSqlContext = (sql, position) => {\n    const currentChar = sql.charCodeAt(position);\n    const nextChar = sql.charCodeAt(position + 1);\n    if (currentChar === charCode.singleQuote) {\n        for (let cursor = position + 1; cursor < sql.length; cursor++) {\n            if (sql.charCodeAt(cursor) === charCode.backslash)\n                cursor++;\n            else if (sql.charCodeAt(cursor) === charCode.singleQuote)\n                return cursor + 1;\n        }\n        return sql.length;\n    }\n    if (currentChar === charCode.dash && nextChar === charCode.dash) {\n        const lineBreak = sql.indexOf('\\n', position + 2);\n        return lineBreak === -1 ? sql.length : lineBreak + 1;\n    }\n    if (currentChar === charCode.slash && nextChar === charCode.asterisk) {\n        const commentEnd = sql.indexOf('*/', position + 2);\n        return commentEnd === -1 ? sql.length : commentEnd + 2;\n    }\n    return -1;\n};\nconst findNextPlaceholder = (sql, start) => {\n    const sqlLength = sql.length;\n    for (let position = start; position < sqlLength; position++) {\n        const code = sql.charCodeAt(position);\n        if (code === charCode.questionMark)\n            return position;\n        if (code === charCode.singleQuote ||\n            code === charCode.dash ||\n            code === charCode.slash) {\n            const contextEnd = skipSqlContext(sql, position);\n            if (contextEnd !== -1)\n                position = contextEnd - 1;\n        }\n    }\n    return -1;\n};\nconst findSetKeyword = (sql, startFrom = 0) => {\n    const length = sql.length;\n    for (let position = startFrom; position < length; position++) {\n        const code = sql.charCodeAt(position);\n        const lower = code | 32;\n        if (code === charCode.singleQuote ||\n            code === charCode.dash ||\n            code === charCode.slash) {\n            const contextEnd = skipSqlContext(sql, position);\n            if (contextEnd !== -1) {\n                position = contextEnd - 1;\n                continue;\n            }\n        }\n        if (lower === 115 && matchesWord(sql, position, 'set', length))\n            return position + 3;\n        if (lower === 107 && matchesWord(sql, position, 'key', length)) {\n            let cursor = position + 3;\n            while (cursor < length && isWhitespace(sql.charCodeAt(cursor)))\n                cursor++;\n            if (matchesWord(sql, cursor, 'update', length))\n                return cursor + 6;\n        }\n    }\n    return -1;\n};\nconst isDate = (value) => Object.prototype.toString.call(value) === '[object Date]';\nconst hasSqlString = (value) => typeof value === 'object' &&\n    value !== null &&\n    'toSqlString' in value &&\n    typeof value.toSqlString === 'function';\nconst escapeString = (value) => {\n    regex.escapeChars.lastIndex = 0;\n    let chunkIndex = 0;\n    let escapedValue = '';\n    let match;\n    for (match = regex.escapeChars.exec(value); match !== null; match = regex.escapeChars.exec(value)) {\n        escapedValue += value.slice(chunkIndex, match.index);\n        escapedValue += CHARS_ESCAPE_MAP[match[0]];\n        chunkIndex = regex.escapeChars.lastIndex;\n    }\n    if (chunkIndex === 0)\n        return `'${value}'`;\n    if (chunkIndex < value.length)\n        return `'${escapedValue}${value.slice(chunkIndex)}'`;\n    return `'${escapedValue}'`;\n};\nconst pad2 = (value) => (value < 10 ? '0' + value : '' + value);\nconst pad3 = (value) => value < 10 ? '00' + value : value < 100 ? '0' + value : '' + value;\nconst pad4 = (value) => value < 10\n    ? '000' + value\n    : value < 100\n        ? '00' + value\n        : value < 1000\n            ? '0' + value\n            : '' + value;\nconst convertTimezone = (tz) => {\n    if (tz === 'Z')\n        return 0;\n    const timezoneMatch = tz.match(regex.timezone);\n    if (timezoneMatch)\n        return ((timezoneMatch[1] === '-' ? -1 : 1) *\n            (Number.parseInt(timezoneMatch[2], 10) +\n                (timezoneMatch[3] ? Number.parseInt(timezoneMatch[3], 10) : 0) / 60) *\n            60);\n    return false;\n};\nconst dateToString = (date, timezone) => {\n    if (Number.isNaN(date.getTime()))\n        return 'NULL';\n    let year;\n    let month;\n    let day;\n    let hour;\n    let minute;\n    let second;\n    let millisecond;\n    if (timezone === 'local') {\n        year = date.getFullYear();\n        month = date.getMonth() + 1;\n        day = date.getDate();\n        hour = date.getHours();\n        minute = date.getMinutes();\n        second = date.getSeconds();\n        millisecond = date.getMilliseconds();\n    }\n    else {\n        const timezoneOffsetMinutes = convertTimezone(timezone);\n        let time = date.getTime();\n        if (timezoneOffsetMinutes !== false && timezoneOffsetMinutes !== 0)\n            time += timezoneOffsetMinutes * 60000;\n        const adjustedDate = new Date(time);\n        year = adjustedDate.getUTCFullYear();\n        month = adjustedDate.getUTCMonth() + 1;\n        day = adjustedDate.getUTCDate();\n        hour = adjustedDate.getUTCHours();\n        minute = adjustedDate.getUTCMinutes();\n        second = adjustedDate.getUTCSeconds();\n        millisecond = adjustedDate.getUTCMilliseconds();\n    }\n    // YYYY-MM-DD HH:mm:ss.mmm\n    return escapeString(pad4(year) +\n        '-' +\n        pad2(month) +\n        '-' +\n        pad2(day) +\n        ' ' +\n        pad2(hour) +\n        ':' +\n        pad2(minute) +\n        ':' +\n        pad2(second) +\n        '.' +\n        pad3(millisecond));\n};\nexports.dateToString = dateToString;\nconst escapeId = (value, forbidQualified) => {\n    if (Array.isArray(value)) {\n        const length = value.length;\n        const parts = new Array(length);\n        for (let i = 0; i < length; i++)\n            parts[i] = (0, exports.escapeId)(value[i], forbidQualified);\n        return parts.join(', ');\n    }\n    const identifier = String(value);\n    const hasJsonOperator = identifier.indexOf('->') !== -1;\n    if (forbidQualified || hasJsonOperator) {\n        if (identifier.indexOf('`') === -1)\n            return `\\`${identifier}\\``;\n        return `\\`${identifier.replace(regex.backtick, '``')}\\``;\n    }\n    if (identifier.indexOf('`') === -1 && identifier.indexOf('.') === -1)\n        return `\\`${identifier}\\``;\n    return `\\`${identifier\n        .replace(regex.backtick, '``')\n        .replace(regex.dot, '`.`')}\\``;\n};\nexports.escapeId = escapeId;\nconst objectToValues = (object, timezone) => {\n    const keys = Object.keys(object);\n    const keysLength = keys.length;\n    if (keysLength === 0)\n        return '';\n    let sql = '';\n    for (let i = 0; i < keysLength; i++) {\n        const key = keys[i];\n        const value = object[key];\n        if (typeof value === 'function')\n            continue;\n        if (sql.length > 0)\n            sql += ', ';\n        sql += (0, exports.escapeId)(key);\n        sql += ' = ';\n        sql += (0, exports.escape)(value, true, timezone);\n    }\n    return sql;\n};\nexports.objectToValues = objectToValues;\nconst bufferToString = (buffer) => `X${escapeString(buffer.toString('hex'))}`;\nexports.bufferToString = bufferToString;\nconst arrayToList = (array, timezone) => {\n    const length = array.length;\n    const parts = new Array(length);\n    for (let i = 0; i < length; i++) {\n        const value = array[i];\n        if (Array.isArray(value))\n            parts[i] = `(${(0, exports.arrayToList)(value, timezone)})`;\n        else\n            parts[i] = (0, exports.escape)(value, true, timezone);\n    }\n    return parts.join(', ');\n};\nexports.arrayToList = arrayToList;\nconst escape = (value, stringifyObjects, timezone) => {\n    if (value === undefined || value === null)\n        return 'NULL';\n    switch (typeof value) {\n        case 'boolean':\n            return value ? 'true' : 'false';\n        case 'number':\n        case 'bigint':\n            return value + '';\n        case 'object': {\n            if (isDate(value))\n                return (0, exports.dateToString)(value, timezone || 'local');\n            if (Array.isArray(value))\n                return (0, exports.arrayToList)(value, timezone);\n            if (node_buffer_1.Buffer.isBuffer(value))\n                return (0, exports.bufferToString)(value);\n            if (value instanceof Uint8Array)\n                return (0, exports.bufferToString)(node_buffer_1.Buffer.from(value));\n            if (hasSqlString(value))\n                return String(value.toSqlString());\n            if (!(stringifyObjects === undefined || stringifyObjects === null))\n                return escapeString(String(value));\n            if (isRecord(value))\n                return (0, exports.objectToValues)(value, timezone);\n            return escapeString(String(value));\n        }\n        case 'string':\n            return escapeString(value);\n        default:\n            return escapeString(String(value));\n    }\n};\nexports.escape = escape;\nconst format = (sql, values, stringifyObjects, timezone) => {\n    if (values === undefined || values === null)\n        return sql;\n    const valuesArray = Array.isArray(values) ? values : [values];\n    const length = valuesArray.length;\n    let setIndex = -2; // -2 = not yet computed, -1 = no SET found\n    let result = '';\n    let chunkIndex = 0;\n    let valuesIndex = 0;\n    let placeholderPosition = findNextPlaceholder(sql, 0);\n    while (valuesIndex < length && placeholderPosition !== -1) {\n        // Count consecutive question marks to detect ? vs ?? vs ???+\n        let placeholderEnd = placeholderPosition + 1;\n        let escapedValue;\n        while (sql.charCodeAt(placeholderEnd) === 63)\n            placeholderEnd++;\n        const placeholderLength = placeholderEnd - placeholderPosition;\n        const currentValue = valuesArray[valuesIndex];\n        if (placeholderLength > 2) {\n            placeholderPosition = findNextPlaceholder(sql, placeholderEnd);\n            continue;\n        }\n        if (placeholderLength === 2)\n            escapedValue = (0, exports.escapeId)(currentValue);\n        else if (typeof currentValue === 'number')\n            escapedValue = `${currentValue}`;\n        else if (typeof currentValue === 'object' &&\n            currentValue !== null &&\n            !stringifyObjects) {\n            // Lazy: compute SET position only when we first encounter an object\n            if (setIndex === -2)\n                setIndex = findSetKeyword(sql);\n            if (setIndex !== -1 &&\n                setIndex <= placeholderPosition &&\n                hasOnlyWhitespaceBetween(sql, setIndex, placeholderPosition) &&\n                !hasSqlString(currentValue) &&\n                !Array.isArray(currentValue) &&\n                !node_buffer_1.Buffer.isBuffer(currentValue) &&\n                !(currentValue instanceof Uint8Array) &&\n                !isDate(currentValue) &&\n                isRecord(currentValue)) {\n                escapedValue = (0, exports.objectToValues)(currentValue, timezone);\n                setIndex = findSetKeyword(sql, placeholderEnd);\n            }\n            else\n                escapedValue = (0, exports.escape)(currentValue, true, timezone);\n        }\n        else\n            escapedValue = (0, exports.escape)(currentValue, stringifyObjects, timezone);\n        result += sql.slice(chunkIndex, placeholderPosition);\n        result += escapedValue;\n        chunkIndex = placeholderEnd;\n        valuesIndex++;\n        placeholderPosition = findNextPlaceholder(sql, placeholderEnd);\n    }\n    if (chunkIndex === 0)\n        return sql;\n    if (chunkIndex < sql.length)\n        return result + sql.slice(chunkIndex);\n    return result;\n};\nexports.format = format;\nconst raw = (sql) => {\n    if (typeof sql !== 'string')\n        throw new TypeError('argument sql must be a string');\n    return {\n        toSqlString: () => sql,\n    };\n};\nexports.raw = raw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsLWVzY2FwZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsZ0JBQWdCLEdBQUcsb0JBQW9CO0FBQy9KLHNCQUFzQixtQkFBTyxDQUFDLGdDQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQSxtQkFBbUIsYUFBYSxFQUFFLHdCQUF3QjtBQUMxRCxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQyxvQkFBb0IseUNBQXlDO0FBQzdEO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixnQkFBZ0I7QUFDaEI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUNBQXVDLHFDQUFxQztBQUM1RSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLDJCQUEyQiwwQ0FBMEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxMdWlTaG93XFxEZXNrdG9wXFxhcHAgbGltcGV6YVxcbm9kZV9tb2R1bGVzXFxzcWwtZXNjYXBlclxcbGliXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9teXNxbGpzL3NxbHN0cmluZy9ibG9iL2NkNTI4NTU2YjRiNmJjZjMwMGMzZGI1MTUwMjY5MzVkZWRmN2NmYTEvbGliL1NxbFN0cmluZy5qc1xuICogTUlUIExJQ0VOU0U6IGh0dHBzOi8vZ2l0aHViLmNvbS9teXNxbGpzL3NxbHN0cmluZy9ibG9iL2NkNTI4NTU2YjRiNmJjZjMwMGMzZGI1MTUwMjY5MzVkZWRmN2NmYTEvTElDRU5TRVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhdyA9IGV4cG9ydHMuZm9ybWF0ID0gZXhwb3J0cy5lc2NhcGUgPSBleHBvcnRzLmFycmF5VG9MaXN0ID0gZXhwb3J0cy5idWZmZXJUb1N0cmluZyA9IGV4cG9ydHMub2JqZWN0VG9WYWx1ZXMgPSBleHBvcnRzLmVzY2FwZUlkID0gZXhwb3J0cy5kYXRlVG9TdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBub2RlX2J1ZmZlcl8xID0gcmVxdWlyZShcIm5vZGU6YnVmZmVyXCIpO1xuY29uc3QgcmVnZXggPSB7XG4gICAgYmFja3RpY2s6IC9gL2csXG4gICAgZG90OiAvXFwuL2csXG4gICAgdGltZXpvbmU6IC8oWytcXC1cXHNdKShcXGRcXGQpOj8oXFxkXFxkKT8vLFxuICAgIGVzY2FwZUNoYXJzOiAvW1xcMFxcYlxcdFxcblxcclxceDFhXCInXFxcXF0vZyxcbn07XG5jb25zdCBDSEFSU19FU0NBUEVfTUFQID0ge1xuICAgICdcXDAnOiAnXFxcXDAnLFxuICAgICdcXGInOiAnXFxcXGInLFxuICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICdcXHInOiAnXFxcXHInLFxuICAgICdcXHgxYSc6ICdcXFxcWicsXG4gICAgJ1wiJzogJ1xcXFxcIicsXG4gICAgXCInXCI6IFwiXFxcXCdcIixcbiAgICAnXFxcXCc6ICdcXFxcXFxcXCcsXG59O1xuY29uc3QgY2hhckNvZGUgPSB7XG4gICAgc2luZ2xlUXVvdGU6IDM5LFxuICAgIGJhY2tzbGFzaDogOTIsXG4gICAgZGFzaDogNDUsXG4gICAgc2xhc2g6IDQ3LFxuICAgIGFzdGVyaXNrOiA0MixcbiAgICBxdWVzdGlvbk1hcms6IDYzLFxuICAgIG5ld2xpbmU6IDEwLFxuICAgIHNwYWNlOiAzMixcbiAgICB0YWI6IDksXG4gICAgY2FycmlhZ2VSZXR1cm46IDEzLFxufTtcbmNvbnN0IGlzUmVjb3JkID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbmNvbnN0IGlzV29yZENoYXIgPSAoY29kZSkgPT4gKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikgfHxcbiAgICAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgIGNvZGUgPT09IDk1O1xuY29uc3QgaXNXaGl0ZXNwYWNlID0gKGNvZGUpID0+IGNvZGUgPT09IGNoYXJDb2RlLnNwYWNlIHx8XG4gICAgY29kZSA9PT0gY2hhckNvZGUudGFiIHx8XG4gICAgY29kZSA9PT0gY2hhckNvZGUubmV3bGluZSB8fFxuICAgIGNvZGUgPT09IGNoYXJDb2RlLmNhcnJpYWdlUmV0dXJuO1xuY29uc3QgaGFzT25seVdoaXRlc3BhY2VCZXR3ZWVuID0gKHNxbCwgc3RhcnQsIGVuZCkgPT4ge1xuICAgIGlmIChzdGFydCA+PSBlbmQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzcWwuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgIT09IGNoYXJDb2RlLnNwYWNlICYmXG4gICAgICAgICAgICBjb2RlICE9PSBjaGFyQ29kZS50YWIgJiZcbiAgICAgICAgICAgIGNvZGUgIT09IGNoYXJDb2RlLm5ld2xpbmUgJiZcbiAgICAgICAgICAgIGNvZGUgIT09IGNoYXJDb2RlLmNhcnJpYWdlUmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCB0b0xvd2VyID0gKGNvZGUpID0+IGNvZGUgfCAzMjtcbmNvbnN0IG1hdGNoZXNXb3JkID0gKHNxbCwgcG9zaXRpb24sIHdvcmQsIGxlbmd0aCkgPT4ge1xuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHdvcmQubGVuZ3RoOyBvZmZzZXQrKylcbiAgICAgICAgaWYgKHRvTG93ZXIoc3FsLmNoYXJDb2RlQXQocG9zaXRpb24gKyBvZmZzZXQpKSAhPT0gd29yZC5jaGFyQ29kZUF0KG9mZnNldCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICgocG9zaXRpb24gPT09IDAgfHwgIWlzV29yZENoYXIoc3FsLmNoYXJDb2RlQXQocG9zaXRpb24gLSAxKSkpICYmXG4gICAgICAgIChwb3NpdGlvbiArIHdvcmQubGVuZ3RoID49IGxlbmd0aCB8fFxuICAgICAgICAgICAgIWlzV29yZENoYXIoc3FsLmNoYXJDb2RlQXQocG9zaXRpb24gKyB3b3JkLmxlbmd0aCkpKSk7XG59O1xuY29uc3Qgc2tpcFNxbENvbnRleHQgPSAoc3FsLCBwb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gc3FsLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIGNvbnN0IG5leHRDaGFyID0gc3FsLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKTtcbiAgICBpZiAoY3VycmVudENoYXIgPT09IGNoYXJDb2RlLnNpbmdsZVF1b3RlKSB7XG4gICAgICAgIGZvciAobGV0IGN1cnNvciA9IHBvc2l0aW9uICsgMTsgY3Vyc29yIDwgc3FsLmxlbmd0aDsgY3Vyc29yKyspIHtcbiAgICAgICAgICAgIGlmIChzcWwuY2hhckNvZGVBdChjdXJzb3IpID09PSBjaGFyQ29kZS5iYWNrc2xhc2gpXG4gICAgICAgICAgICAgICAgY3Vyc29yKys7XG4gICAgICAgICAgICBlbHNlIGlmIChzcWwuY2hhckNvZGVBdChjdXJzb3IpID09PSBjaGFyQ29kZS5zaW5nbGVRdW90ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3FsLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRDaGFyID09PSBjaGFyQ29kZS5kYXNoICYmIG5leHRDaGFyID09PSBjaGFyQ29kZS5kYXNoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVCcmVhayA9IHNxbC5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbiArIDIpO1xuICAgICAgICByZXR1cm4gbGluZUJyZWFrID09PSAtMSA/IHNxbC5sZW5ndGggOiBsaW5lQnJlYWsgKyAxO1xuICAgIH1cbiAgICBpZiAoY3VycmVudENoYXIgPT09IGNoYXJDb2RlLnNsYXNoICYmIG5leHRDaGFyID09PSBjaGFyQ29kZS5hc3Rlcmlzaykge1xuICAgICAgICBjb25zdCBjb21tZW50RW5kID0gc3FsLmluZGV4T2YoJyovJywgcG9zaXRpb24gKyAyKTtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnRFbmQgPT09IC0xID8gc3FsLmxlbmd0aCA6IGNvbW1lbnRFbmQgKyAyO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuY29uc3QgZmluZE5leHRQbGFjZWhvbGRlciA9IChzcWwsIHN0YXJ0KSA9PiB7XG4gICAgY29uc3Qgc3FsTGVuZ3RoID0gc3FsLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwb3NpdGlvbiA9IHN0YXJ0OyBwb3NpdGlvbiA8IHNxbExlbmd0aDsgcG9zaXRpb24rKykge1xuICAgICAgICBjb25zdCBjb2RlID0gc3FsLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgICAgICBpZiAoY29kZSA9PT0gY2hhckNvZGUucXVlc3Rpb25NYXJrKVxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICBpZiAoY29kZSA9PT0gY2hhckNvZGUuc2luZ2xlUXVvdGUgfHxcbiAgICAgICAgICAgIGNvZGUgPT09IGNoYXJDb2RlLmRhc2ggfHxcbiAgICAgICAgICAgIGNvZGUgPT09IGNoYXJDb2RlLnNsYXNoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0RW5kID0gc2tpcFNxbENvbnRleHQoc3FsLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAoY29udGV4dEVuZCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjb250ZXh0RW5kIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuY29uc3QgZmluZFNldEtleXdvcmQgPSAoc3FsLCBzdGFydEZyb20gPSAwKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gc3FsLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwb3NpdGlvbiA9IHN0YXJ0RnJvbTsgcG9zaXRpb24gPCBsZW5ndGg7IHBvc2l0aW9uKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHNxbC5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgbG93ZXIgPSBjb2RlIHwgMzI7XG4gICAgICAgIGlmIChjb2RlID09PSBjaGFyQ29kZS5zaW5nbGVRdW90ZSB8fFxuICAgICAgICAgICAgY29kZSA9PT0gY2hhckNvZGUuZGFzaCB8fFxuICAgICAgICAgICAgY29kZSA9PT0gY2hhckNvZGUuc2xhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRFbmQgPSBza2lwU3FsQ29udGV4dChzcWwsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0RW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gY29udGV4dEVuZCAtIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyID09PSAxMTUgJiYgbWF0Y2hlc1dvcmQoc3FsLCBwb3NpdGlvbiwgJ3NldCcsIGxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gKyAzO1xuICAgICAgICBpZiAobG93ZXIgPT09IDEwNyAmJiBtYXRjaGVzV29yZChzcWwsIHBvc2l0aW9uLCAna2V5JywgbGVuZ3RoKSkge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHBvc2l0aW9uICsgMztcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBsZW5ndGggJiYgaXNXaGl0ZXNwYWNlKHNxbC5jaGFyQ29kZUF0KGN1cnNvcikpKVxuICAgICAgICAgICAgICAgIGN1cnNvcisrO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNXb3JkKHNxbCwgY3Vyc29yLCAndXBkYXRlJywgbGVuZ3RoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yICsgNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuY29uc3QgaXNEYXRlID0gKHZhbHVlKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7XG5jb25zdCBoYXNTcWxTdHJpbmcgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICd0b1NxbFN0cmluZycgaW4gdmFsdWUgJiZcbiAgICB0eXBlb2YgdmFsdWUudG9TcWxTdHJpbmcgPT09ICdmdW5jdGlvbic7XG5jb25zdCBlc2NhcGVTdHJpbmcgPSAodmFsdWUpID0+IHtcbiAgICByZWdleC5lc2NhcGVDaGFycy5sYXN0SW5kZXggPSAwO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICBsZXQgZXNjYXBlZFZhbHVlID0gJyc7XG4gICAgbGV0IG1hdGNoO1xuICAgIGZvciAobWF0Y2ggPSByZWdleC5lc2NhcGVDaGFycy5leGVjKHZhbHVlKTsgbWF0Y2ggIT09IG51bGw7IG1hdGNoID0gcmVnZXguZXNjYXBlQ2hhcnMuZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgZXNjYXBlZFZhbHVlICs9IHZhbHVlLnNsaWNlKGNodW5rSW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgZXNjYXBlZFZhbHVlICs9IENIQVJTX0VTQ0FQRV9NQVBbbWF0Y2hbMF1dO1xuICAgICAgICBjaHVua0luZGV4ID0gcmVnZXguZXNjYXBlQ2hhcnMubGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoY2h1bmtJbmRleCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGAnJHt2YWx1ZX0nYDtcbiAgICBpZiAoY2h1bmtJbmRleCA8IHZhbHVlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGAnJHtlc2NhcGVkVmFsdWV9JHt2YWx1ZS5zbGljZShjaHVua0luZGV4KX0nYDtcbiAgICByZXR1cm4gYCcke2VzY2FwZWRWYWx1ZX0nYDtcbn07XG5jb25zdCBwYWQyID0gKHZhbHVlKSA9PiAodmFsdWUgPCAxMCA/ICcwJyArIHZhbHVlIDogJycgKyB2YWx1ZSk7XG5jb25zdCBwYWQzID0gKHZhbHVlKSA9PiB2YWx1ZSA8IDEwID8gJzAwJyArIHZhbHVlIDogdmFsdWUgPCAxMDAgPyAnMCcgKyB2YWx1ZSA6ICcnICsgdmFsdWU7XG5jb25zdCBwYWQ0ID0gKHZhbHVlKSA9PiB2YWx1ZSA8IDEwXG4gICAgPyAnMDAwJyArIHZhbHVlXG4gICAgOiB2YWx1ZSA8IDEwMFxuICAgICAgICA/ICcwMCcgKyB2YWx1ZVxuICAgICAgICA6IHZhbHVlIDwgMTAwMFxuICAgICAgICAgICAgPyAnMCcgKyB2YWx1ZVxuICAgICAgICAgICAgOiAnJyArIHZhbHVlO1xuY29uc3QgY29udmVydFRpbWV6b25lID0gKHR6KSA9PiB7XG4gICAgaWYgKHR6ID09PSAnWicpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHRpbWV6b25lTWF0Y2ggPSB0ei5tYXRjaChyZWdleC50aW1lem9uZSk7XG4gICAgaWYgKHRpbWV6b25lTWF0Y2gpXG4gICAgICAgIHJldHVybiAoKHRpbWV6b25lTWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMSkgKlxuICAgICAgICAgICAgKE51bWJlci5wYXJzZUludCh0aW1lem9uZU1hdGNoWzJdLCAxMCkgK1xuICAgICAgICAgICAgICAgICh0aW1lem9uZU1hdGNoWzNdID8gTnVtYmVyLnBhcnNlSW50KHRpbWV6b25lTWF0Y2hbM10sIDEwKSA6IDApIC8gNjApICpcbiAgICAgICAgICAgIDYwKTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgZGF0ZVRvU3RyaW5nID0gKGRhdGUsIHRpbWV6b25lKSA9PiB7XG4gICAgaWYgKE51bWJlci5pc05hTihkYXRlLmdldFRpbWUoKSkpXG4gICAgICAgIHJldHVybiAnTlVMTCc7XG4gICAgbGV0IHllYXI7XG4gICAgbGV0IG1vbnRoO1xuICAgIGxldCBkYXk7XG4gICAgbGV0IGhvdXI7XG4gICAgbGV0IG1pbnV0ZTtcbiAgICBsZXQgc2Vjb25kO1xuICAgIGxldCBtaWxsaXNlY29uZDtcbiAgICBpZiAodGltZXpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgbW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgICBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgaG91ciA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgbWludXRlID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgIHNlY29uZCA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICBtaWxsaXNlY29uZCA9IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0aW1lem9uZU9mZnNldE1pbnV0ZXMgPSBjb252ZXJ0VGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICBsZXQgdGltZSA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICBpZiAodGltZXpvbmVPZmZzZXRNaW51dGVzICE9PSBmYWxzZSAmJiB0aW1lem9uZU9mZnNldE1pbnV0ZXMgIT09IDApXG4gICAgICAgICAgICB0aW1lICs9IHRpbWV6b25lT2Zmc2V0TWludXRlcyAqIDYwMDAwO1xuICAgICAgICBjb25zdCBhZGp1c3RlZERhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcbiAgICAgICAgeWVhciA9IGFkanVzdGVkRGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICBtb250aCA9IGFkanVzdGVkRGF0ZS5nZXRVVENNb250aCgpICsgMTtcbiAgICAgICAgZGF5ID0gYWRqdXN0ZWREYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgaG91ciA9IGFkanVzdGVkRGF0ZS5nZXRVVENIb3VycygpO1xuICAgICAgICBtaW51dGUgPSBhZGp1c3RlZERhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICBzZWNvbmQgPSBhZGp1c3RlZERhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICBtaWxsaXNlY29uZCA9IGFkanVzdGVkRGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB9XG4gICAgLy8gWVlZWS1NTS1ERCBISDptbTpzcy5tbW1cbiAgICByZXR1cm4gZXNjYXBlU3RyaW5nKHBhZDQoeWVhcikgK1xuICAgICAgICAnLScgK1xuICAgICAgICBwYWQyKG1vbnRoKSArXG4gICAgICAgICctJyArXG4gICAgICAgIHBhZDIoZGF5KSArXG4gICAgICAgICcgJyArXG4gICAgICAgIHBhZDIoaG91cikgK1xuICAgICAgICAnOicgK1xuICAgICAgICBwYWQyKG1pbnV0ZSkgK1xuICAgICAgICAnOicgK1xuICAgICAgICBwYWQyKHNlY29uZCkgK1xuICAgICAgICAnLicgK1xuICAgICAgICBwYWQzKG1pbGxpc2Vjb25kKSk7XG59O1xuZXhwb3J0cy5kYXRlVG9TdHJpbmcgPSBkYXRlVG9TdHJpbmc7XG5jb25zdCBlc2NhcGVJZCA9ICh2YWx1ZSwgZm9yYmlkUXVhbGlmaWVkKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGFydHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhcnRzW2ldID0gKDAsIGV4cG9ydHMuZXNjYXBlSWQpKHZhbHVlW2ldLCBmb3JiaWRRdWFsaWZpZWQpO1xuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLCAnKTtcbiAgICB9XG4gICAgY29uc3QgaWRlbnRpZmllciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgaGFzSnNvbk9wZXJhdG9yID0gaWRlbnRpZmllci5pbmRleE9mKCctPicpICE9PSAtMTtcbiAgICBpZiAoZm9yYmlkUXVhbGlmaWVkIHx8IGhhc0pzb25PcGVyYXRvcikge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCdgJykgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke2lkZW50aWZpZXJ9XFxgYDtcbiAgICAgICAgcmV0dXJuIGBcXGAke2lkZW50aWZpZXIucmVwbGFjZShyZWdleC5iYWNrdGljaywgJ2BgJyl9XFxgYDtcbiAgICB9XG4gICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignYCcpID09PSAtMSAmJiBpZGVudGlmaWVyLmluZGV4T2YoJy4nKSA9PT0gLTEpXG4gICAgICAgIHJldHVybiBgXFxgJHtpZGVudGlmaWVyfVxcYGA7XG4gICAgcmV0dXJuIGBcXGAke2lkZW50aWZpZXJcbiAgICAgICAgLnJlcGxhY2UocmVnZXguYmFja3RpY2ssICdgYCcpXG4gICAgICAgIC5yZXBsYWNlKHJlZ2V4LmRvdCwgJ2AuYCcpfVxcYGA7XG59O1xuZXhwb3J0cy5lc2NhcGVJZCA9IGVzY2FwZUlkO1xuY29uc3Qgb2JqZWN0VG9WYWx1ZXMgPSAob2JqZWN0LCB0aW1lem9uZSkgPT4ge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIGNvbnN0IGtleXNMZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoa2V5c0xlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGxldCBzcWwgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChzcWwubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHNxbCArPSAnLCAnO1xuICAgICAgICBzcWwgKz0gKDAsIGV4cG9ydHMuZXNjYXBlSWQpKGtleSk7XG4gICAgICAgIHNxbCArPSAnID0gJztcbiAgICAgICAgc3FsICs9ICgwLCBleHBvcnRzLmVzY2FwZSkodmFsdWUsIHRydWUsIHRpbWV6b25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbn07XG5leHBvcnRzLm9iamVjdFRvVmFsdWVzID0gb2JqZWN0VG9WYWx1ZXM7XG5jb25zdCBidWZmZXJUb1N0cmluZyA9IChidWZmZXIpID0+IGBYJHtlc2NhcGVTdHJpbmcoYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSl9YDtcbmV4cG9ydHMuYnVmZmVyVG9TdHJpbmcgPSBidWZmZXJUb1N0cmluZztcbmNvbnN0IGFycmF5VG9MaXN0ID0gKGFycmF5LCB0aW1lem9uZSkgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcGFydHNbaV0gPSBgKCR7KDAsIGV4cG9ydHMuYXJyYXlUb0xpc3QpKHZhbHVlLCB0aW1lem9uZSl9KWA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhcnRzW2ldID0gKDAsIGV4cG9ydHMuZXNjYXBlKSh2YWx1ZSwgdHJ1ZSwgdGltZXpvbmUpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignLCAnKTtcbn07XG5leHBvcnRzLmFycmF5VG9MaXN0ID0gYXJyYXlUb0xpc3Q7XG5jb25zdCBlc2NhcGUgPSAodmFsdWUsIHN0cmluZ2lmeU9iamVjdHMsIHRpbWV6b25lKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnTlVMTCc7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIGlmIChpc0RhdGUodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5kYXRlVG9TdHJpbmcpKHZhbHVlLCB0aW1lem9uZSB8fCAnbG9jYWwnKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuYXJyYXlUb0xpc3QpKHZhbHVlLCB0aW1lem9uZSk7XG4gICAgICAgICAgICBpZiAobm9kZV9idWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5idWZmZXJUb1N0cmluZykodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuYnVmZmVyVG9TdHJpbmcpKG5vZGVfYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChoYXNTcWxTdHJpbmcodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUudG9TcWxTdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAoIShzdHJpbmdpZnlPYmplY3RzID09PSB1bmRlZmluZWQgfHwgc3RyaW5naWZ5T2JqZWN0cyA9PT0gbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZyhTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChpc1JlY29yZCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLm9iamVjdFRvVmFsdWVzKSh2YWx1ZSwgdGltZXpvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZyhTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlU3RyaW5nKFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cbn07XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbmNvbnN0IGZvcm1hdCA9IChzcWwsIHZhbHVlcywgc3RyaW5naWZ5T2JqZWN0cywgdGltZXpvbmUpID0+IHtcbiAgICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQgfHwgdmFsdWVzID09PSBudWxsKVxuICAgICAgICByZXR1cm4gc3FsO1xuICAgIGNvbnN0IHZhbHVlc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc107XG4gICAgY29uc3QgbGVuZ3RoID0gdmFsdWVzQXJyYXkubGVuZ3RoO1xuICAgIGxldCBzZXRJbmRleCA9IC0yOyAvLyAtMiA9IG5vdCB5ZXQgY29tcHV0ZWQsIC0xID0gbm8gU0VUIGZvdW5kXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICBsZXQgdmFsdWVzSW5kZXggPSAwO1xuICAgIGxldCBwbGFjZWhvbGRlclBvc2l0aW9uID0gZmluZE5leHRQbGFjZWhvbGRlcihzcWwsIDApO1xuICAgIHdoaWxlICh2YWx1ZXNJbmRleCA8IGxlbmd0aCAmJiBwbGFjZWhvbGRlclBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAvLyBDb3VudCBjb25zZWN1dGl2ZSBxdWVzdGlvbiBtYXJrcyB0byBkZXRlY3QgPyB2cyA/PyB2cyA/Pz8rXG4gICAgICAgIGxldCBwbGFjZWhvbGRlckVuZCA9IHBsYWNlaG9sZGVyUG9zaXRpb24gKyAxO1xuICAgICAgICBsZXQgZXNjYXBlZFZhbHVlO1xuICAgICAgICB3aGlsZSAoc3FsLmNoYXJDb2RlQXQocGxhY2Vob2xkZXJFbmQpID09PSA2MylcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyRW5kKys7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyTGVuZ3RoID0gcGxhY2Vob2xkZXJFbmQgLSBwbGFjZWhvbGRlclBvc2l0aW9uO1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB2YWx1ZXNBcnJheVt2YWx1ZXNJbmRleF07XG4gICAgICAgIGlmIChwbGFjZWhvbGRlckxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyUG9zaXRpb24gPSBmaW5kTmV4dFBsYWNlaG9sZGVyKHNxbCwgcGxhY2Vob2xkZXJFbmQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyTGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgZXNjYXBlZFZhbHVlID0gKDAsIGV4cG9ydHMuZXNjYXBlSWQpKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgZXNjYXBlZFZhbHVlID0gYCR7Y3VycmVudFZhbHVlfWA7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFzdHJpbmdpZnlPYmplY3RzKSB7XG4gICAgICAgICAgICAvLyBMYXp5OiBjb21wdXRlIFNFVCBwb3NpdGlvbiBvbmx5IHdoZW4gd2UgZmlyc3QgZW5jb3VudGVyIGFuIG9iamVjdFxuICAgICAgICAgICAgaWYgKHNldEluZGV4ID09PSAtMilcbiAgICAgICAgICAgICAgICBzZXRJbmRleCA9IGZpbmRTZXRLZXl3b3JkKHNxbCk7XG4gICAgICAgICAgICBpZiAoc2V0SW5kZXggIT09IC0xICYmXG4gICAgICAgICAgICAgICAgc2V0SW5kZXggPD0gcGxhY2Vob2xkZXJQb3NpdGlvbiAmJlxuICAgICAgICAgICAgICAgIGhhc09ubHlXaGl0ZXNwYWNlQmV0d2VlbihzcWwsIHNldEluZGV4LCBwbGFjZWhvbGRlclBvc2l0aW9uKSAmJlxuICAgICAgICAgICAgICAgICFoYXNTcWxTdHJpbmcoY3VycmVudFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAhbm9kZV9idWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIoY3VycmVudFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICEoY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkgJiZcbiAgICAgICAgICAgICAgICAhaXNEYXRlKGN1cnJlbnRWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICBpc1JlY29yZChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZFZhbHVlID0gKDAsIGV4cG9ydHMub2JqZWN0VG9WYWx1ZXMpKGN1cnJlbnRWYWx1ZSwgdGltZXpvbmUpO1xuICAgICAgICAgICAgICAgIHNldEluZGV4ID0gZmluZFNldEtleXdvcmQoc3FsLCBwbGFjZWhvbGRlckVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZXNjYXBlZFZhbHVlID0gKDAsIGV4cG9ydHMuZXNjYXBlKShjdXJyZW50VmFsdWUsIHRydWUsIHRpbWV6b25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlc2NhcGVkVmFsdWUgPSAoMCwgZXhwb3J0cy5lc2NhcGUpKGN1cnJlbnRWYWx1ZSwgc3RyaW5naWZ5T2JqZWN0cywgdGltZXpvbmUpO1xuICAgICAgICByZXN1bHQgKz0gc3FsLnNsaWNlKGNodW5rSW5kZXgsIHBsYWNlaG9sZGVyUG9zaXRpb24pO1xuICAgICAgICByZXN1bHQgKz0gZXNjYXBlZFZhbHVlO1xuICAgICAgICBjaHVua0luZGV4ID0gcGxhY2Vob2xkZXJFbmQ7XG4gICAgICAgIHZhbHVlc0luZGV4Kys7XG4gICAgICAgIHBsYWNlaG9sZGVyUG9zaXRpb24gPSBmaW5kTmV4dFBsYWNlaG9sZGVyKHNxbCwgcGxhY2Vob2xkZXJFbmQpO1xuICAgIH1cbiAgICBpZiAoY2h1bmtJbmRleCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHNxbDtcbiAgICBpZiAoY2h1bmtJbmRleCA8IHNxbC5sZW5ndGgpXG4gICAgICAgIHJldHVybiByZXN1bHQgKyBzcWwuc2xpY2UoY2h1bmtJbmRleCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmNvbnN0IHJhdyA9IChzcWwpID0+IHtcbiAgICBpZiAodHlwZW9mIHNxbCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNxbCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9TcWxTdHJpbmc6ICgpID0+IHNxbCxcbiAgICB9O1xufTtcbmV4cG9ydHMucmF3ID0gcmF3O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sql-escaper/lib/index.js\n");

/***/ })

};
;